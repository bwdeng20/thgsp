import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

from thgsp.graphs.core import GraphBase


def to_nx_pos(pos, G):
    if pos is None:
        pos = nx.spring_layout(G)

    elif not isinstance(pos, dict):
        pos = np.asarray(pos)
        pos = {i: pos[i] for i in range(pos.shape[0])}
    elif isinstance(pos, dict):
        pass
    else:
        raise TypeError("{} is not valid position type".format(type(pos)))
    return pos


def draw(G: GraphBase, pos=None, ax=None, node_size=225, with_labels=True, **kwargs):
    G = G.to_networkx(G.is_directed)
    pos = to_nx_pos(pos, G)
    return nx.draw(G, pos, ax, with_labels=with_labels, node_size=node_size, **kwargs)


def draw_cn(
    G: GraphBase,
    pos=None,
    node_color=None,
    ax=None,
    cmap=None,
    node_size=225,
    with_labels=True,
    **kwargs
):
    if G.n_node > 4000:
        with_labels = False
    if node_color is None:
        node_color = range(G.n_node)
    else:  # adjust the order of vertex to coincide with the networkx
        node_color = np.asarray(node_color)
    if cmap is None:
        cmap = plt.get_cmap("coolwarm")
    return draw(
        G,
        pos=pos,
        ax=ax,
        node_color=node_color,
        node_size=node_size,
        cmap=cmap,
        with_labels=with_labels,
        **kwargs
    )


def draw_signal(
    G: GraphBase,
    pos=None,
    signal=None,
    ax=None,
    cmap=None,
    vmin=None,
    vmax=None,
    cbar=True,
    edge_cmap=None,
    node_size=225,
    with_labels=True,
    **kwargs
):
    """

    Parameters
    ----------
    G:  Graph, DiGraph
        The graph to be displayed
    signal: Tensor, List, Tuple
            A :obj:`(N,)` tensor carrying signals. `:obj:`signal[i]` is the value of graph signal at the i-th vertex.
    pos:    Tensor, optional
            :obj:`(N,D)`  N is the number of nodes, and D is the dimension of node coordinates. If :py:obj:`None`,
            the positions generated by :py:func:`networkx.spring_layout` will be used.
    ax:    matplotlib.axes.Axes
    cbar:   bool,optional
            If True, show the colorbar of graph signal.
    cmap:   matplotlib.colors.Colormap, optional
            The colormap for signal value
    edge_cmap:   matplotlib.colors.Colormap, optional
            The colormap for edge weight
    node_size: int,optional
            The radius of node circle
    with_labels:bool
            If True, the node ordinal will be annotated in the circle unless there are more than 4000 nodes.
            If False, the node ordinal will not be drawn.

    kwargs:   other args can be parsed by matplotlib

    Returns
    -------
    matplotlib.collections.PathCollection
              `PathCollection` of the nodes.
    """
    # node_size: font_size=300:16
    G = G.to_networkx(G.is_directed)
    if signal is None:
        signal = np.ones(G.number_of_nodes())
    if cmap is None:
        cmap = plt.get_cmap("coolwarm")
    if edge_cmap is None:
        weights = np.ones(G.number_of_edges())
        edge_cmap = plt.get_cmap("copper")
    else:
        _, weights = zip(*nx.get_edge_attributes(G, "weight").items())

    if ax is None:
        ax = plt.gca()

    pos = to_nx_pos(pos, G)

    signal_shuffled = [signal[v] for v in G]

    nodes = nx.draw_networkx_nodes(
        G,
        pos,
        ax=ax,
        node_color=signal_shuffled,
        node_size=node_size,
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        **kwargs
    )
    nx.draw_networkx_edges(
        G, pos, ax=ax, edge_color=weights, edge_cmap=edge_cmap, **kwargs
    )

    if with_labels and len(G) <= 1000:
        nx.draw_networkx_labels(G, pos, ax=ax, **kwargs)
    if cbar:
        plt.colorbar(nodes, fraction=0.046, pad=0.04, ax=ax)
    ax.set_axis_off()
    return nodes
